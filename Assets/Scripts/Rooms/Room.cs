//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
namespace AssemblyCSharp
{
	public class Room : MonoBehaviour
	{
		bool doorNorth = false;
		bool doorEast  = false;
		bool doorSouth = false;
		bool doorWest  = false;

		public const int offset_amount = 14;

		public Room ()
		{
		}

		public void addSourceDoor(FloorManager.Direction dir)
		{
			switch (dir)
			{
				case FloorManager.Direction.NORTH:
					doorNorth = true;
				break;
				case FloorManager.Direction.EAST:
					doorEast = true;
				break;
				case FloorManager.Direction.SOUTH:
					doorSouth = true;
				break;
				case FloorManager.Direction.WEST:
					doorWest = true;
				break;
			}
		}

		public void addUnexploredDoor(FloorManager.Direction dir)
		{
			// sanitize input
			if (dir > FloorManager.Direction.WEST)
			{
				addUnexploredDoor(dir-4);
				return;
			}

			Vector2 trans = new Vector2(0,0);
			bool rotate = false;

			Vector2 myCoord = (Vector2) FloorGraph.singleton.get (this);

			switch (dir)
			{
				case FloorManager.Direction.NORTH:
					if(doorNorth)
					{
						// don't make a door where a door already exists
						// instead make a door one step clockwise
						addUnexploredDoor(dir+1);
						return;
					}
				    else
					{
						// make sure there is empty space to build a new room in
						myCoord.y += 1;
						Room adj = FloorGraph.singleton.get(myCoord);
						if(adj != null)
						{
							if(adj.doorSouth) doorNorth = true;
							return;
						}

						// door is good, actually make it
						doorNorth = true;
						trans.y += offset_amount/2+0.4f;
					}
				break;
				case FloorManager.Direction.EAST:
					if(doorEast)
					{
						addUnexploredDoor(dir+1);
						return;
					}
				    else
					{
						myCoord.x += 1;
						Room adj = FloorGraph.singleton.get(myCoord);
						if(adj != null)
						{
							if(adj.doorWest) doorEast = true;
							return;
						}

						doorEast = true;
						rotate = true;
						trans.x += offset_amount/2+0.4f;
					}
				break;
				case FloorManager.Direction.SOUTH:
					if(doorSouth)
					{
						addUnexploredDoor(dir+1);
						return;
					}
				    else
					{
						myCoord.y -= 1;
						Room adj = FloorGraph.singleton.get(myCoord);
						if(adj != null)
						{
							if(adj.doorNorth) doorSouth = true;
							return;
						}

						doorSouth = true;
						trans.y -= offset_amount/2+0.4f;
					}
				break;
				case FloorManager.Direction.WEST:
					if(doorWest)
					{
						addUnexploredDoor(dir-3);
						return;
					}
				    else
					{
						myCoord.x -= 1;
						Room adj = FloorGraph.singleton.get(myCoord);
						if(adj != null)
						{
							if(adj.doorEast) doorWest = true;
							return;
						}

						doorWest = true;
						rotate = true;
						trans.x -= offset_amount/2+0.4f;
					}
				break;
			}
			int deg = (rotate) ? 90 : 0;
			Door d = (Door) Instantiate(Resources.Load<Door>("Prefabs/Door"), transform.position, transform.rotation*Quaternion.Euler(0,0,deg));
			d.rigidbody2D.position += trans;
			d.room = this;
			d.dir = dir;
		}

		public void generateWalls()
		{
			Vector2 myCoord = (Vector2) FloorGraph.singleton.get (this);

			// Make sure to allow door access and not to layer walls over doors
			for(int x = -offset_amount/2; x <= offset_amount/2; x++)
			{
				if((x != 0 || !doorNorth))
				{
					if(x == 0)
					{
						myCoord.y += 1;
						Room adj = FloorGraph.singleton.get(myCoord);
						if(adj != null)
						{
							if(adj.doorSouth) continue;
						}
						myCoord.y -= 1;
					}
					Wall w = (Wall) Instantiate(Resources.Load<Wall>("Prefabs/Wall"), transform.position, transform.rotation);
					w.rigidbody2D.position += new Vector2(x,offset_amount/2+0.4f);
				}
				if((x != 0 || !doorSouth))
				{
					if(x == 0)
					{
						myCoord.y -= 1;
						Room adj = FloorGraph.singleton.get(myCoord);
						if(adj != null)
						{
							if(adj.doorNorth) continue;
						}
						myCoord.y += 1;
					}
					Wall w = (Wall) Instantiate(Resources.Load<Wall>("Prefabs/Wall"), transform.position, transform.rotation);
					w.rigidbody2D.position += new Vector2(x,-offset_amount/2-0.4f);
				}
			}
			for(int y = -offset_amount/2; y <= offset_amount/2; y++)
			{
				if((y != 0 || !doorEast))
				{
					if(y == 0)
					{
						myCoord.x += 1;
						Room adj = FloorGraph.singleton.get(myCoord);
						if(adj != null)
						{
							if(adj.doorWest) continue;
						}
						myCoord.x -= 1;
					}
					Wall w = (Wall) Instantiate(Resources.Load<Wall>("Prefabs/Wall"), transform.position, transform.rotation*Quaternion.Euler(0, 0, 90));
					w.rigidbody2D.position += new Vector2(offset_amount/2+0.4f,y);
				}
				if((y != 0 || !doorWest))
				{
					if(y == 0)
					{
						myCoord.x -= 1;
						Room adj = FloorGraph.singleton.get(myCoord);
						if(adj != null)
						{
							if(adj.doorEast) continue;
						}
						myCoord.x += 1;
					}
					Wall w = (Wall) Instantiate(Resources.Load<Wall>("Prefabs/Wall"), transform.position, transform.rotation*Quaternion.Euler(0, 0, 90));
					w.rigidbody2D.position += new Vector2(-offset_amount/2-0.4f,y);
				}
			}
		}

		public void doSpawn()
		{
			Debug.Log ("doSpawn");
			
			int monsterCount = (int) Math.Ceiling(Probability<int>.random.NextDouble() * 10);
			for (int i = 0; i < monsterCount; i++)
			{
				float x = (float) ((Probability<int>.random.NextDouble() * offset_amount) - offset_amount/2);
				float y = (float) ((Probability<int>.random.NextDouble() * offset_amount) - offset_amount/2);

				Vector2 spawnOffset = new Vector2(x, y);
				Debug.Log("spawnOffset = " + spawnOffset);
				
				Enemy enemy = (Enemy) Instantiate(Resources.Load<Enemy>("Prefabs/Enemy"), transform.position, transform.rotation);
				enemy.rigidbody2D.position += spawnOffset;

				Debug.Log("SpawnPos = " + enemy.rigidbody2D.position);
			}
		}
	}
}

